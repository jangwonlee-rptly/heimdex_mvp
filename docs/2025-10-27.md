# Heimdex Repository Notes — 2025-10-27

## Overview
- Heimdex ingests raw video, normalises ffprobe output into a rich “sidecar” JSON, and manages derived artefacts (thumbnails, schema snapshots) for each asset.
- Two API layers coexist: a legacy minimal `/metadata` endpoint defined inline in `app/main.py` and a newer modular FastAPI application exposed under `/v1` (`app/api/v1`).
- The service targets multi-tenant operation with org-scoped data isolation, async job orchestration, and pluggable storage backends.

## Architecture Outline
- **Entry point:** `app/main.py` defines `create_app()` to initialise settings, logging, storage, DB engine/session factory, includes versioned routers, and exposes `app`.
- **API package:** `app/api/v1/__init__.py` assembles routers covering system, admin, ingest, asset, and job concerns.
- **Domain layer:** `app/domain/__init__.py` re-exports ingest helpers to keep API/service layers decoupled from older ingest code organisation.
- **Service layer:** `app/services/ingest_service.py` centralises ingest orchestration, persistence, job scheduling, and background job handlers.
- **Background jobs:** `app/core/jobs.py` selects either inline execution or Redis/RQ-based queues; `app/workers/tasks.py` hosts the `run_job` entry-point.
- **Storage abstraction:** `app/core/storage.py` now includes `LocalStorage` and a stubbed `GCSStorage`. Selection is driven by `HEIMDEX_STORAGE_BACKEND` (default `local`).
- **Configuration:** `app/core/config.py` loads Pydantic settings with `HEIMDEX_` prefix, covering storage, DB, auth, job queue, and limits.
- **Database:** `app/core/db.py` wires SQLAlchemy async engine/session; models live in `app/db/models.py`; Alembic migrations under `migrations/`.

## API Surface
- **System health:** `/v1/health` (`routes_system.py`) returns simple uptime status.
- **Admin tooling:** `/v1/admin/env-check` (`routes_admin.py`) validates ffmpeg/ffprobe/PySceneDetect availability; gated by `admin` scope.
- **Dev helper:** When `HEIMDEX_ENV=development`, `/v1/admin/dev-token` mints HS256 JWTs so local clients don’t need manual token generation.
- **Ingest lifecycle:** `/v1/ingest` endpoints (`routes_ingest.py`) handle upload init, commit, and synchronous probe. Payloads enforce org-level scope checks via `AuthContext`.
- **Asset management:** `/v1/assets/{asset_id}` (`routes_assets.py`) exposes asset metadata, triggers asynchronous sidecar/thumbnail jobs, enforces org ownership, and serves stored sidecars via the storage abstraction.
- **Job tracking:** `/v1/jobs/{job_id}` (`routes_jobs.py`) returns job status, result, and error payloads.
- **Legacy endpoint:** An upload-based `/metadata` route (with `/health`) now hides behind the `HEIMDEX_ENABLE_LEGACY` flag. It remains available for transitional clients but is disabled by default.

## Authentication & Authorisation
- `app/core/auth.py` implements a minimal JWT decoder with `HEIMDEX_JWT_SECRET`; expects `org_id` (or `tenant`) claim and optional `scopes`. Missing tokens cause 401, cross-org access triggers 403.
- Request-scoped `AuthContext` is cached on `request.state` for reuse by downstream dependencies.

## Configuration & Environment
- `.env` values feed Pydantic `Settings`; includes DB URL, Redis URL, derived artefact root, storage backend selection, JWT config, upload size limits, job queue type, and allowed source URI schemes.
- Three tracked templates (`.env.example.dev`, `.env.example.staging`, `.env.example.prod`) provide opinionated defaults with placeholders for secrets.
- Defaults favour local SQLite/aiosqlite and immediate jobs but support Postgres/Redis via `docker-compose.yml`.
- Metrics push endpoint and retry parameters already defined for future instrumentation/backoff logic.

## Storage Strategy
- `LocalStorage` operates relative to `settings.local_storage_base_path` or `derived_root`. Provides read/write/presign and list helpers, storing objects under predictable directories (e.g., `uploads/{org}/{upload_id}`).
- Presign responses return file URIs in development; S3 implementation placeholder raises `NotImplementedError`.
- Asset sidecars and thumbnails end up under `derived/{org_id}/sidecars` and `derived/{org_id}/{asset_id}/thumbs`; storage keys recorded in DB.

## Database & Persistence
- SQLAlchemy models (`app/db/models.py`) capture organisations, assets, sidecars, thumbnails, jobs, and audit events. Enum types enforce allowed statuses/job types.
- Alembic migration `20241010_000001_initial_schema.py` creates all core tables, indexes, and unique constraints (e.g., idempotency key uniqueness, job org-asset index).
- Tests bootstrap SQLite in temp directories (`tests/conftest.py`) and drop schema after each run.

## Ingest Workflow
- `IngestService.init_upload` ensures the org exists and returns a presigned upload URI plus `upload_id`.
- `commit_upload` resolves `file://` URIs, derives strong/weak hashes (`app/ingest/asset_id.py`), persists/updates the `Asset` record, and returns canonical asset metadata. Upload size is validated against `Settings.max_upload_size_bytes` in the router.
- `probe` executes ffprobe on demand, builds `SourceContext` (size, timestamps, hashes), and normalises output via `parse_ffprobe_json`.
- `get_asset_snapshot` composes a summary document with pointers to sidecar/thumbnails for API responses.

## Background Jobs & Idempotency
- Job dispatch uses `get_job_backend()`; inline backend runs `run_job` in a thread for local dev, while RQ backend enqueues to Redis queue `heimdex-jobs`.
- `enqueue_job` enforces per-org idempotency by comparing payloads when an `Idempotency-Key` header is supplied (see `routes_assets.py` and tests). Payload mismatches raise `idempotency_conflict` → HTTP 409.
- `process_thumbnails_job` and `process_sidecar_job` share a common pattern: mark job running, probe source, ensure derived directories, generate thumbnails (`render_thumbnails`), persist manifests into DB, update asset status, and finalise job with results.
- Sidecar job additionally exports JSON schema (`export_schema`) and writes sidecar to disk before recording storage key.

## Sidecar Construction & Thumbnails
- `parse_ffprobe_json` (large module) ingests ffprobe JSON, records provenance (tool versions via `_binary_version`), handles duration/bitrate parsing, stream normalisation, default stream selection, and tag cleanup. Warnings/errors capture anomalies (missing audio, duration unavailable, etc.).
- Thumbnail manifest logic chooses poster at mid-point of duration and sample intervals, later materialised by `render_thumbnails`.
- `render_thumbnails` uses ffmpeg & OpenCV to capture frames at prescribed timestamps, scaling to `THUMB_WIDTH=320`, and records actual dimensions. Failures append `thumbnail_generation_failed` warning.
- Schema validation provided by Pydantic models in `app/ingest/sidecar_schema.py`; `export_schema` snapshots JSON for clients.

## CLI Tooling
- `app/cli.py` offers developer commands: `probe`, `thumbs`, `sidecar`, plus `--check` for dependency validation. Commands reuse ingest helpers and print JSON via `rich`.
- The CLI writes sidecars to `derived/sidecars/{asset_id}.vna.json` when running `sidecar`.

## Logging & Observability
- `configure_logging` sets up structured JSON logging with `structlog` and contextvars; default INFO level.
- `app/main.py` also configures a Rich handler for the legacy routes — the coexistence of two logging setups merits alignment later.
- Job processors bind job id/type to log entries via `get_logger`.

## Testing & Quality Gates
- Pytest suite covers:
  - API happy paths, idempotency, and permission enforcement (`tests/test_api_v1.py`).
  - Hash derivation and Drive identity composition (`tests/test_asset_id.py`).
  - ffprobe parsing edge cases and tag handling (`tests/test_ffprobe_parser.py`).
  - Thumbnail rendering contract (`tests/test_thumbnails.py`).
  - Sidecar schema export and validation (`tests/test_sidecar_schema.py`).
- Fixtures spin up temp SQLite DB, derived directories, real ffmpeg-generated sample media, and JWT helpers. Background jobs run inline during tests.

## Local Development & Deployment
- `Dockerfile` builds on `python:3.11-slim`, installs ffmpeg/ffprobe, Astral `uv`, and runs FastAPI via `uv run fastapi run app/main.py --app app`.
- `docker-compose.yml` provisions Postgres, Redis, and the API container with bind mounts for live code, data, tests, and derived output. Healthcheck hits `/v1/health`.
- `pyproject.toml` lists core deps (FastAPI, Pydantic, SQLAlchemy, async drivers, Redis/RQ, structlog, ffmpeg/python, OpenCV) and optional test extras (pytest/httpx/fakeredis).
- Alembic config (`alembic.ini`) and migrations exist for DB evolution; `app/services/ingest_service.process_sidecar_job` exports schema to `derived/schemas` at runtime.

## Notable Design Decisions & Gaps
- **Dual API implementations:** `app/main.py` conditionally mounts the legacy upload-based endpoint behind `HEIMDEX_ENABLE_LEGACY`. Plan to remove it once consumers migrate.
- **Storage abstraction:** Local remains default. A stub `gcs` backend accepts `gs://` URIs behind the feature flag, with methods still raising `NotImplementedError` until wiring is complete.
- **Idempotency scope:** Enforced per-org and per idempotency key; payload mismatches treated as conflicts rather than reusing existing job with different parameters.
- **Job scheduling:** Immediate backend simplifies dev/testing but still runs jobs in a background thread; production expects Redis-backed RQ.
- **Security model:** JWT validation is minimal (no signature rotation, audience checks disabled, scopes unchecked beyond simple tuple membership). Designed as stub pending integration with upstream auth.
- **Metrics & retries:** Settings hint at retry/backoff logic, but actual retry orchestration is not yet implemented.
- **Tests rely on system ffmpeg/ffprobe:** CI must ensure these binaries exist; Dockerfile already installs them.
- **Derived artefact layout:** Sidecars stored under `derived/{org}/sidecars` while thumbnails move into `derived/{org}/{asset}/thumbs`, with helper to clean temporary `thumbs` staging directory.

## Suggested Follow-ups
- Align logging configuration between legacy and modular app sections, potentially removing the obsolete inline API once clients migrate to `/v1`.
- Implement S3 storage backend or guard configuration to prevent accidental selection.
- Add retry handling for background jobs leveraging `Settings.job_max_retries` parameters.
- Expand admin endpoints for queue visibility/metrics, matching planned roadmap items referenced in `README.md`.
